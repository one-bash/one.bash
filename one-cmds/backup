#!/usr/bin/env bash

set -o errexit -o nounset -o pipefail -o errtrace
(shopt -p inherit_errexit &>/dev/null) && shopt -s inherit_errexit

# one.bash:completion
if [[ ${1:-} == --complete ]]; then
	if ((COMP_CWORD < 3)); then
		words=(-o -h --help)
		printf '%s\n' "${words[@]}"
	elif [[ $2 == -o ]]; then
		result=$(compgen -f -- "$3")
		if [[ -d $result ]]; then
			compgen -f -- "$result/"
		else
			echo "${result[@]}"
		fi
	fi
	exit 0
fi

usage() {
	# editorconfig-checker-disable
	cat <<EOF
Usage: one backup [OPTIONS]
Desc:  Output backup scripts for current enabled modules
Options:
  -h, --help           Show usage
  -o, --output <PATH>  Output the content to file.
EOF
	# editorconfig-checker-enable
}

# one.bash:usage
if [[ ${1:-} == -h ]] || [[ ${1:-} == --help ]]; then
	usage
	exit 0
fi

if [[ -z ${ONE_DIR:-} ]]; then
	ONE_DIR=$(realpath "$0")
	ONE_DIR=${ONE_DIR%/*}
	ONE_DIR=${ONE_DIR%/*}
	declare -rx ONE_DIR
fi

# shellcheck source=./base-scripts.bash
. "$ONE_DIR/one-cmds/base-scripts.bash"

# shellcheck source=../one-cmds/mod.bash
. "$ONE_DIR/one-cmds/mod.bash"

list_enabled_for_backup() {
	list_enabled "$1" | sort | tr '\n' ' '
	printf '\n'
}

list_enabled_bins() {
	find "$ENABLED_DIR/bin" -maxdepth 1 -type l -exec basename {} \; |
		sort | tr '\n' ' '
	printf '\n'
}

list_enabled_subs() {
	find "$ENABLED_DIR/sub" -maxdepth 1 -type l -exec basename {} \; |
		sort | tr '\n' ' '
	printf '\n'
}

backup_content() {
	cat <<EOF
#!/usr/bin/env bash

set -o errexit -o nounset -o pipefail -o errtrace
(shopt -p inherit_errexit &>/dev/null) && shopt -s inherit_errexit

one a disable --all
one b disable --all
one c disable --all
one d disable --all
one p disable --all

EOF

	local path url
	for path in "$ONE_DIR"/enabled/repo/*; do
		if [[ -d $path/.git ]]; then
			url=$(git -C "$path" config --get remote.origin.url)
		else
			url=$(readlink "$path")
		fi
		echo "one repo add $url"
	done

	printf '\n'
	printf "%s %s\n\n" "one alias enable" "$(list_enabled_for_backup alias)"
	printf "%s %s\n\n" "one completion enable" "$(list_enabled_for_backup completion)"
	printf "%s %s\n\n" "one bin enable" "$(list_enabled_bins)"
	printf "%s %s\n\n" "one sub enable" "$(list_enabled_subs)"
	printf "%s %s\n\n" "one plugin enable" "$(list_enabled_for_backup plugin)"
	printf '\necho "[All Done]"\n'
}

declare -A opts=()
declare -a args=()
declare -A opts_def=(
	[opts]=opts
	[args]=args
	['-o --output']='default:/dev/stdout'
)
l.parse_args opts_def "$@"

main() {
	dist="${opts[o]}"

	if [[ $dist == /dev/stdout ]]; then
		backup_content
	elif [[ $dist == /dev/stderr ]]; then
		backup_content >&2
	else
		backup_content | tee "$dist"
		chmod +x "$dist"
		print_success "Created backup file: $dist"
	fi
}
main
